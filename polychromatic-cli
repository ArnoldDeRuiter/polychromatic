#!/usr/bin/python3
#
# Polychromatic is free software: you can redistribute it and/or modify
# it under the temms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Polychromatic is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Polychromatic. If not, see <http://www.gnu.org/licenses/>.
#
# Copyright (C) 2017-2020 Luke Horwell <code@horwell.me>
#

"""
Control Razer devices from the command line. Useful for commamd line users or bash scripting.
"""
VERSION = "0.6.0"

import argparse
import colorama
import signal
import os
import sys

# Import modules if running relatively.
if os.path.exists(os.path.join(os.path.dirname(__file__), "pylib")):
    try:
        import pylib.preferences as pref
        import pylib.common as common
        import pylib.locales as locales
        import pylib.middleman as middleman_module
    except (ImportError, Exception) as e:
        print("Failed to import modules relatively.\n")
        raise e

# Import modules if installed system.-wide.
else:
    try:
        import polychromatic.preferences as pref
        import polychromatic.common as common
        import polychromatic.locales as locales
        import polychromatic.middleman as middleman_module
    except (ImportError, Exception) as e:
        print("Polychromatic's modules could not be imported.")
        print("Check all dependencies are installed, the Python environment variables are correct, or try re-installing the application.\n")
        print(str(e))
        exit(1)


########################################
# Set up variables
########################################
dbg = common.Debugging()
path = pref.Paths()
_ = locales._
signal.signal(signal.SIGINT, signal.SIG_DFL)
verbose = False


########################################
# Parse arguments
########################################
parser = argparse.ArgumentParser(add_help=False)
parser._optionals.title = _("These arguments can be specified")

# Select a device
parser.add_argument("-d", "--device", help=_("Select device(s) by form factor. If omitted, select all devices."), action="store", choices=common.FORM_FACTORS)
parser.add_argument("--serial", help=_("Select a device by its serial number"), action="store")

# Output details only
parser.add_argument("-l", "--list-devices", help=_("List connected device(s) and their zones"), action="store_true")
parser.add_argument("-k", "--list-options", help=_("List supported parameters for selected device(s)"), action="store_true")

# Device manipulation
parser.add_argument("-z", "--zone", help=_("Make change to specific zone. If omitted, use all available zones"))
parser.add_argument("-o", "--option", help=_("Change a feature on the device"), action="store")
parser.add_argument("-p", "--parameter", help=_("Set parameter for the option (if applicable)"), action="store")
parser.add_argument("-c", "--colours", help=_("Set colours in hex format. Comma separated. If omitted, use last colours"))

# Special handling
parser.add_argument("--dpi", help=_("Set how fast the cursor moves. Example: 1800 or 1800,800"), action="store")

# Misc
parser.add_argument("--version", help=_("Print version and exit"), action="store_true")
parser.add_argument("-h", "--help", help=_("Show this help message and exit"), action="help")
parser.add_argument("--locale", help=_("Force a specific language, e.g. de_DE"), action="store")
parser.add_argument("-v", "--verbose", help=_("Output verbose messages for debugging"), action="store_true")

args = parser.parse_args()

# Was anything passed?
if not len(sys.argv) > 1:
    dbg.stdout(_("No arguments passed."), dbg.error)
    dbg.stdout(_("Type polychromatic-cli --help to see possible combinations."))
    exit(0)

if args.version:
    dbg.stdout(_("Version") + " " + VERSION)
    exit(0)

if args.locale:
    _ = locales.reload_locales(locales, __file__, args.locale)

if args.verbose:
    dbg.verbose_level = 1
    verbose = True


########################################
# Pretty columns
########################################
def print_columns(data, print_header=False):
    """
    Prints a basic 'pretty' table ensuring each column has enough room.

    Params:
        data = [
            ["Row 1 Column 2", "Row 1 Column 2", "Row 1 Column 3"]
            ["Row 2 Column 2", "Row 2 Column 2", "Row 2 Column 3"]
        ]
    """
    total_cols = 0
    col_widths = {}
    col_pos = {}

    def _back_to_start():
        # Move cursor to beginning of line
        for i in range(0, total_cols * 10):
            print(colorama.Cursor.BACK(), end="")

    def _jump_to_pos(x):
        # Move cursor to specified position
        _back_to_start()
        for i in range(0, x):
            print(colorama.Cursor.FORWARD(), end="")

    # Calculate the columns dimensions before printing
    for row in data:
        for index, col in enumerate(row):
            line = col

            # Strip formatting characters from calculation
            for char in [dbg.error, dbg.success, dbg.grey, dbg.normal]:
                line = line.replace(char, "")

            # Make note of largest width and total columns.
            try:
                if len(line) > col_widths[index]:
                    col_widths[index] = len(line)
            except KeyError:
                col_widths[index] = len(line)
            total_cols = total_cols + col_widths[index]

    for index, col in enumerate(row):
        # Precalculate the column positions
        col_pos[index] = 0
        for i in range(0, index):
            col_pos[index] += col_widths[i] + 2

    # Print the actual data
    for index, row in enumerate(data):
        # Print header background
        if print_header and index == 0:
            print(colorama.Back.WHITE + colorama.Fore.BLACK, end="")

        # Print aligned columns
        for index, col in enumerate(row):
            _jump_to_pos(col_pos[index])
            print(col,end="")
        print(colorama.Style.RESET_ALL)

########################################
# Select devices
########################################
middleman = middleman_module.Middleman(dbg, common)
middleman.init()

if verbose:
    dbg.stdout("Loaded {0} backend(s):".format(len(middleman.backends)), dbg.success)
    for backend in middleman.backends:
        dbg.stdout(" - {0}".format(middleman_module.BACKEND_ID_NAMES[backend.backend_id]), dbg.success)

    if len(middleman.not_installed) > 0:
        dbg.stdout("Not imported: " + ", ".join(middleman.not_installed), dbg.debug)

    if len(middleman.import_errors) > 0:
        dbg.stdout("Errors:", dbg.warning)
        for error in middleman.import_errors:
            dbg.stdout(" - {0}".format(error), dbg.warning)

if len(middleman.backends) == 0:
    dbg.stdout(_("No backends avaliable."), dbg.error)
    exit(1)

if args.device:
    device_list = middleman.get_filtered_device_list(args.device)
else:
    device_list = middleman.get_device_list()

if args.serial:
    for device in device_list:
        if device["serial"] == str(args.serial):
            device_list = [device]
            break

unsupported_list = middleman.get_unsupported_devices()

if len(device_list) == 0:
    dbg.stdout(_("No devices connected."), dbg.error)
    exit(1)


########################################
# List devices, zones or current status.
########################################
if args.list_devices:
    dbg.stdout("Connected Devices:", dbg.success)
    table = [[
        _("Name"),
        _("Form Factor"),
        _("Serial"),
        _("Zones")
    ]]

    for device in device_list:
        table.append([
            "{0}{1}".format(dbg.normal, device["name"]),
            "{0}{1}".format(dbg.blue, device["form_factor"]["id"]),
            "{0}{1}".format(dbg.warning, device["serial"]),
            "{0}{1}".format(dbg.magenta, ", ".join(device["zones"]))
        ])

    for device in unsupported_list:
        table.append([
            "{0}{2}: {1}".format(dbg.error, device["name"], middleman_module.BACKEND_ID_NAMES[device["backend"]])
        ])

    print_columns(table, True)

if args.list_options:
    for device in device_list:
        print("")
        details = middleman.get_device(device["backend"], int(device["uid"]))
        rows = []

        if details == None:
            continue

        elif details == str:
            dbg.stdout(_("Could not retrieve device information:") + '\n' + details)
            rows.append([_("Backend"), middleman_module.BACKEND_ID_NAMES[device["backend"]]])
            dbg.stdout(details, dbg.error)
            continue

        dbg.stdout("[{0}]".format(details["name"]), dbg.action)

        # Print device information
        def _add_row(label, value, colour):
            rows.append([colour + label, colour + value])

        if verbose:
            if details["vid"] and details["pid"]:
                _add_row("VID:PID", "{0}:{1}".format(details["vid"], details["pid"]), dbg.grey)

            if details["serial"]:
                _add_row(_("Serial"), details["serial"], dbg.grey)

            if details["firmware_version"]:
                _add_row(_("Firmware Version"), details["firmware_version"], dbg.grey)

            if details["keyboard_layout"]:
                _add_row(_("Keyboard Layout"), details["keyboard_layout"], dbg.grey)

            if details["matrix"]:
                dimensions = "{0} {2}, {1} {3}".format(details["matrix_rows"], details["matrix_cols"], _("rows"), _("columns"))
            else:
                _add_row(_("Custom Effects"), _("Not supported"), dbg.error)

            if details["matrix"] and not details["monochromatic"]:
                _add_row(_("Custom Effects"), "{0} ({1})".format(_("Yes"), dimensions), dbg.success)

            if details["matrix"] and details["monochromatic"]:
                _add_row(_("Custom Effects"), "{0} ({1})".format(_("Yes (Limited RGB)"), dimensions), dbg.success)

            # Space between details and next table
            _add_row("", "", dbg.normal)
            print_columns(rows)

        # Print options and their parameter/colour inputs
        rows = [[
            _("Zone") + " (-z)",
            _("Option") + " (-o)",
            _("Parameter") + " (-p)",
            _("Colours") + " (-c)"
        ]]

        def _add_row():
            rows.append([col_zone, col_option, col_param, col_colours])

        def _list_colours(colour_count, control):
            if colour_count == 0:
                return dbg.grey + "-"
            cur_colours = []
            listed = 1
            while listed <= colour_count:
                cur_colours.append(control["colour_" + str(listed)].upper())
                listed += 1
            return "{0} ({1})".format(colour_count, ", ".join(cur_colours))

        for zone in details["zone_options"]:
            for control in details["zone_options"][zone]:
                col_zone = dbg.normal + zone
                col_option = dbg.normal + control["id"]
                col_colours = dbg.grey + "-"
                col_param = dbg.grey + "-"

                type = control["type"]
                try:
                    params = control["parameters"]
                except KeyError:
                    params = []

                try:
                    colours = control["colours"]
                except KeyError:
                    colours = 0

                if colours > 0:
                    col_colours = _list_colours(colours, control)

                if type == "slider":
                    col_param = str(control["value"])
                    if control["value"] > 0:
                        col_zone = dbg.success + zone
                        col_option = dbg.success + control["id"]
                        col_param = dbg.success + col_param
                    else:
                        col_zone = dbg.error + zone
                        col_option = dbg.error + control["id"]
                        col_param = dbg.error + col_param
                    _add_row()

                elif type == "toggle":
                    if control["active"]:
                        col_zone = dbg.success + zone
                        col_option = dbg.success + control["id"]
                        col_param = dbg.success + _("On") + " (1)"
                    else:
                        col_zone = dbg.error + zone
                        col_option = dbg.error + control["id"]
                        col_param = dbg.error + _("Off") + " (0)"
                    _add_row()

                elif type in ["multichoice", "effect"] and len(params) == 0:
                    if colours > 0:
                        col_colours = _list_colours(colours, control)

                    if control["active"]:
                        col_zone = dbg.success + zone
                        col_option = dbg.success + control["id"]
                        col_param = dbg.success + "-"
                        col_colours = dbg.success + col_colours
                    else:
                        col_colours = dbg.normal + col_colours
                    _add_row()

                elif type in ["multichoice", "effect"] and len(params) > 0:
                    for param in control["parameters"]:
                        col_zone = dbg.normal + zone
                        col_option = dbg.normal + control["id"]
                        col_colours = dbg.grey + "-"
                        col_param = param["id"]

                        try:
                            if param["active"] and control["active"]:
                                col_zone = dbg.success + zone
                                col_option = dbg.success + control["id"]
                                col_param = dbg.success + col_param
                                col_colours = dbg.success + col_colours
                        except KeyError:
                            pass

                        try:
                            colours = param["colours"]
                            if colours > 0:
                                col_colours = _list_colours(colours, control)
                        except KeyError:
                            pass

                        _add_row()

        print_columns(rows, True)

# After using a --list-* parameter, exit here as devices won't be manipulated.
if args.list_devices or args.list_options:
    exit()


########################################
# Set device state
########################################
apply_zone = args.zone
apply_option = args.option
apply_param = args.parameter
if args.colours:
    apply_colours = args.colours.split(",")
else:
    apply_colours = []

for device_item in device_list:
    device = middleman.get_device(device_item["backend"], device_item["uid"])
    zones = device["zone_options"].keys()

    # Check an option was specified
    if not apply_option:
        dbg.stdout(_("Please specify an option (-o). Use --list-options (-k) to view available options."), dbg.error)
        exit(1)

    # If a zone was specified, does it match this device?
    if apply_zone:
        if apply_zone in zones:
            zones = [apply_zone]
        else:
            dbg.stdout(_("Skipping: [device] - No such zone '[z]'").replace("[z]", apply_zone).replace("[device]", device["name"]), dbg.warning)
            continue

    # Validate the request has the required parameters and colours
    valid = False
    user_colours_count = len(apply_colours)
    device_name = device["name"]

    for zone in zones:
        for option in device["zone_options"][zone]:
            if option["id"] == apply_option:

                # Does this option require parameters?
                try:
                    params = option["parameters"]
                except KeyError:
                    # Not an effect or multichoice type.
                    params = []
                if len(params) > 0 and not apply_param:
                    dbg.stdout(_("Skipping: [device] - Missing a required parameter.").replace("[device]", device_name), dbg.warning)
                    continue

                elif len(params) > 0:
                    valid_param = False

                    # Is a valid parameter listed here?
                    for param in params:
                        # -p may accept 'raw' data as well as the string 'ID'
                        #   E.g. OpenRazer uses 1 or 2 for 'wave', but ID isn't interchangable between devices.
                        #   left/right = mouse, or anticlock/clock = mousemat
                        if str(param["data"]) == str(apply_param):
                            valid_param = True
                            if type(param["data"]) == int:
                                apply_param = int(param["data"])
                            else:
                                apply_param = param["data"]
                            break

                        elif param["id"] == apply_param:
                            valid_param = True
                            apply_param = param["data"]
                            break

                    if not valid_param:
                        dbg.stdout(_("Skipping: [device] - This parameter is not supported.").replace("[device]", device_name), dbg.warning)
                        continue

                    # Do we have all the colours required?
                    try:
                        required_colour_count = param["colours"]

                        if required_colour_count > user_colours_count:
                            dbg.stdout(_("Skipping: [device] - Requires [1] colour(s) but only [2] specified.").replace("[device]", device_name).replace("[1]", str(required_colour_count)).replace("[2]", str(user_colours_count)), dbg.warning)
                            continue
                    except KeyError:
                        if verbose:
                            dbg.stdout("Colours not used for this parameter", dbg.debug)

                    valid = True

                elif len(params) == 0:
                    try:
                        if option["colours"] > len(apply_colours):
                            dbg.stdout(_("Skipping: [device] - Requires [1] colour(s) but only [2] specified.").replace("[device]", device_name).replace("[1]", str(option["colours"])).replace("[2]", str(len(apply_colours))), dbg.warning)
                            continue
                    except KeyError:
                        if verbose:
                            dbg.stdout("Colours not used for this option", dbg.debug)

                    valid = True

    if not valid:
        dbg.stdout(_("Skipping: [device] - This option is not supported.").replace("[device]", device_name), dbg.warning)
        continue

    for zone in zones:
        result = middleman.set_device_state(device["backend"], device["uid"], device["serial"], zone, apply_option, apply_param, apply_colours)

        if result == False:
            # This shouldn't really happen, since the input was validated.
            dbg.stdout(_("Error: [device] - Invalid request!").replace("[device]", device_name), dbg.error)
        elif result == True and verbose:
            dbg.stdout("Successfully executed request.", dbg.success)
        elif type(result) == str:
            dbg.stdout(_("Error: [device] - Backend threw exception:").replace("[device]", device_name), dbg.error)
            dbg.stdout(result, dbg.error)

exit(0)
