#!/usr/bin/python3
#
# Polychromatic is free software: you can redistribute it and/or modify
# it under the temms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Polychromatic is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Polychromatic. If not, see <http://www.gnu.org/licenses/>.
#
# Copyright (C) 2017-2020 Luke Horwell <code@horwell.me>
#

"""
Control Razer devices from the command line. Useful for commamd line users or bash scripting.
"""
VERSION = "0.6.0"

import argparse
import colorama
import signal
import os
import sys

# Import modules if running relatively.
if os.path.exists(os.path.join(os.path.dirname(__file__), "pylib")):
    try:
        import pylib.preferences as pref
        import pylib.common as common
        import pylib.locales as locales
        import pylib.middleman as middleman_module
    except (ImportError, Exception) as e:
        print("Failed to import modules relatively.\n")
        raise e

# Import modules if installed system.-wide.
else:
    try:
        import polychromatic.preferences as pref
        import polychromatic.common as common
        import polychromatic.locales as locales
        import polychromatic.middleman as middleman_module
    except (ImportError, Exception) as e:
        print("Polychromatic's modules could not be imported.")
        print("Check all dependencies are installed, the Python environment variables are correct, or try re-installing the application.\n")
        print(str(e))
        exit(1)


########################################
# Set up variables
########################################
dbg = common.Debugging()
path = pref.Paths()
_ = locales._
signal.signal(signal.SIGINT, signal.SIG_DFL)
verbose = False


########################################
# Valid Options
########################################
possible_form_factors = ["all", "keyboard", "mouse", "mousemat", "keypad", "headset", "gpu", "accessory"]
possible_effects = ["static", "wave", "spectrum", "reactive", "breath", "ripple", "starlight", "blinking", "pulsate"]
possible_poll_rates = ["125", "500", "1000"]

########################################
# Parse arguments
########################################
parser = argparse.ArgumentParser(add_help=False)
parser._optionals.title = _("These arguments can be specified")

# Select a device
parser.add_argument("-d", "--device", help=_("Select device(s) by form factor. Default is 'all'."), action="store", choices=possible_form_factors)
parser.add_argument("--serial", help=_("Select device by its serial number"), action="store")

# Output details only
parser.add_argument("-l", "--list-devices", help=_("List connected device(s) and their zones"), action="store_true")
parser.add_argument("-k", "--list-options", help=_("List supported parameters for selected device(s)"), action="store_true")

# Device manipulation
parser.add_argument("-z", "--zone", help=_("Make change to specific zone. Default is 'all'"))
parser.add_argument("-o", "--option", help=_("Change a device's state"), action="store")
parser.add_argument("-p", "--parameter", help=_("Set parameter for effect"), action="store")
parser.add_argument("-c", "--colours", help=_("Set colours in hex format. Comma separated."))

# Special handling
parser.add_argument("--dpi", help=_("Set how fast the cursor moves. Example: 1800 or 1800,800"), action="store")

# Misc
parser.add_argument("--version", help=_("Print version and exit"), action="store_true")
parser.add_argument("-h", "--help", help=_("Show this help message and exit"), action="help")
parser.add_argument("--locale", help=_("Force a specific language, e.g. de_DE"), action="store")
parser.add_argument("-v", "--verbose", help=_("Output verbose messages for debugging"), action="store_true")

args = parser.parse_args()

# Was anything passed?
if not len(sys.argv) > 1:
    dbg.stdout(_("No arguments passed."), dbg.error)
    dbg.stdout(_("Type polychromatic-cli --help to see possible combinations."))
    exit(0)

if args.version:
    dbg.stdout(_("Version") + " " + VERSION)
    exit(0)

if args.locale:
    _ = locales.reload_locales(locales, __file__, args.locale)

if args.verbose:
    dbg.verbose_level = 1
    verbose = True


########################################
# Pretty columns
########################################
def print_columns(data, print_header=False):
    """
    Prints a basic 'pretty' table ensuring each column has enough room.

    Params:
        data = [
            ["Row 1 Column 2", "Row 1 Column 2", "Row 1 Column 3"]
            ["Row 2 Column 2", "Row 2 Column 2", "Row 2 Column 3"]
        ]
    """
    total_cols = 0
    col_widths = {}
    col_pos = {}

    def _back_to_start():
        # Move cursor to beginning of line
        for i in range(0, total_cols * 10):
            print(colorama.Cursor.BACK(), end="")

    def _jump_to_pos(x):
        # Move cursor to specified position
        _back_to_start()
        for i in range(0, x):
            print(colorama.Cursor.FORWARD(), end="")

    # Calculate the columns dimensions before printing
    for row in data:
        for index, col in enumerate(row):
            line = col

            # Strip formatting characters from calculation
            for char in [dbg.error, dbg.success, dbg.grey, dbg.normal]:
                line = line.replace(char, "")

            # Make note of largest width and total columns.
            try:
                if len(line) > col_widths[index]:
                    col_widths[index] = len(line)
            except KeyError:
                col_widths[index] = len(line)
            total_cols = total_cols + col_widths[index]

    for index, col in enumerate(row):
        # Precalculate the column positions
        col_pos[index] = 0
        for i in range(0, index):
            col_pos[index] += col_widths[i] + 2

    # Print the actual data
    for index, row in enumerate(data):
        # Print header background
        if print_header and index == 0:
            print(colorama.Back.WHITE + colorama.Fore.BLACK, end="")

        # Print aligned columns
        for index, col in enumerate(row):
            _jump_to_pos(col_pos[index])
            print(col,end="")
        print(colorama.Style.RESET_ALL)


########################################
# List devices, zones or current status.
########################################
middleman = middleman_module.Middleman(dbg, common)
middleman.init()

if verbose:
    dbg.stdout("Loaded {0} backend(s):".format(len(middleman.backends)), dbg.success)
    for backend in middleman.backends:
        dbg.stdout(" - {0}".format(middleman_module.BACKEND_ID_NAMES[backend.backend_id]), dbg.success)

    if len(middleman.not_installed) > 0:
        dbg.stdout("Not imported: " + ", ".join(middleman.not_installed), dbg.debug)

    if len(middleman.import_errors) > 0:
        dbg.stdout("Errors:", dbg.warning)
        for error in middleman.import_errors:
            dbg.stdout(" - {0}".format(error), dbg.warning)

if len(middleman.backends) == 0:
    dbg.stdout(_("No backends avaliable."), dbg.error)
    exit(1)

device_list = middleman.get_device_list()
unsupported_list = middleman.get_unsupported_devices()

if len(device_list) == 0:
    dbg.stdout(_("No devices connected."), dbg.error)
    exit(1)

if args.list_devices:
    dbg.stdout("Connected Devices:", dbg.success)
    table = [[
        _("Name"),
        _("Form Factor"),
        _("Serial"),
        _("Zones")
    ]]

    for device in device_list:
        table.append([
            "{0}{1}".format(dbg.normal, device["name"]),
            "{0}{1}".format(dbg.blue, device["form_factor"]["id"]),
            "{0}{1}".format(dbg.warning, device["serial"]),
            "{0}{1}".format(dbg.magenta, ", ".join(device["zones"]))
        ])

    for device in unsupported_list:
        table.append([
            "{0}{2}: {1}".format(dbg.error, device["name"], middleman_module.BACKEND_ID_NAMES[device["backend"]])
        ])

    print_columns(table, True)

if args.list_options:
    for device in device_list:
        print("")
        details = middleman.get_device(device["backend"], int(device["uid"]))
        rows = []

        if details == None:
            continue

        elif details == str:
            dbg.stdout(_("Could not retrieve device information:") + '\n' + details)
            rows.append([_("Backend"), middleman_module.BACKEND_ID_NAMES[device["backend"]]])
            dbg.stdout(details, dbg.error)
            continue

        dbg.stdout("[{0}]".format(details["name"]), dbg.action)

        # Print device information
        def _add_row(label, value, colour):
            rows.append([colour + label, colour + value])

        if verbose:
            if details["vid"] and details["pid"]:
                _add_row("VID:PID", "{0}:{1}".format(details["vid"], details["pid"]), dbg.grey)

            if details["serial"]:
                _add_row(_("Serial"), details["serial"], dbg.grey)

            if details["firmware_version"]:
                _add_row(_("Firmware Version"), details["firmware_version"], dbg.grey)

            if details["keyboard_layout"]:
                _add_row(_("Keyboard Layout"), details["keyboard_layout"], dbg.grey)

            if details["matrix"]:
                dimensions = "{0} {2}, {1} {3}".format(details["matrix_rows"], details["matrix_cols"], _("rows"), _("columns"))
            else:
                _add_row(_("Custom Effects"), _("Not supported"), dbg.error)

            if details["matrix"] and not details["monochromatic"]:
                _add_row(_("Custom Effects"), "{0} ({1})".format(_("Yes"), dimensions), dbg.success)

            if details["matrix"] and details["monochromatic"]:
                _add_row(_("Custom Effects"), "{0} ({1})".format(_("Yes (Limited RGB)"), dimensions), dbg.success)

            # Space between details and next table
            _add_row("", "", dbg.normal)
            print_columns(rows)

        # Print options and their parameter/colour inputs
        rows = [[
            _("Zone") + " (-z)",
            _("Option") + " (-o)",
            _("Parameter") + " (-p)",
            _("Colours") + " (-c)"
        ]]

        def _add_row():
            rows.append([col_zone, col_option, col_param, col_colours])

        def _list_colours(colour_count, control):
            if colour_count == 0:
                return dbg.grey + "-"
            cur_colours = []
            listed = 1
            while listed <= colour_count:
                cur_colours.append(control["colour_" + str(listed)].upper())
                listed += 1
            return "{0} ({1})".format(colour_count, ", ".join(cur_colours))

        for zone in details["zone_options"]:
            for control in details["zone_options"][zone]:
                col_zone = dbg.normal + zone
                col_option = dbg.normal + control["id"]
                col_colours = dbg.grey + "-"
                col_param = dbg.grey + "-"

                type = control["type"]
                try:
                    params = control["parameters"]
                except KeyError:
                    params = []

                try:
                    colours = control["colours"]
                except KeyError:
                    colours = 0

                if colours > 0:
                    col_colours = _list_colours(colours, control)

                if type == "slider":
                    col_param = str(control["value"])
                    if control["value"] > 0:
                        col_zone = dbg.success + zone
                        col_option = dbg.success + control["id"]
                        col_param = dbg.success + col_param
                    else:
                        col_zone = dbg.error + zone
                        col_option = dbg.error + control["id"]
                        col_param = dbg.error + col_param
                    _add_row()

                elif type == "toggle":
                    if control["active"]:
                        col_zone = dbg.success + zone
                        col_option = dbg.success + control["id"]
                        col_param = dbg.success + _("On") + " (1)"
                    else:
                        col_zone = dbg.error + zone
                        col_option = dbg.error + control["id"]
                        col_param = dbg.error + _("Off") + " (0)"
                    _add_row()

                elif type in ["multichoice", "effect"] and len(params) == 0:
                    if colours > 0:
                        col_colours = _list_colours(colours, control)

                    if control["active"]:
                        col_zone = dbg.success + zone
                        col_option = dbg.success + control["id"]
                        col_param = dbg.success + "-"
                        col_colours = dbg.success + col_colours
                    else:
                        col_colours = dbg.normal + col_colours
                    _add_row()

                elif type in ["multichoice", "effect"] and len(params) > 0:
                    for param in control["parameters"]:
                        col_zone = dbg.normal + zone
                        col_option = dbg.normal + control["id"]
                        col_colours = dbg.grey + "-"
                        col_param = param["id"]

                        try:
                            if param["active"] and control["active"]:
                                col_zone = dbg.success + zone
                                col_option = dbg.success + control["id"]
                                col_param = dbg.success + col_param
                                col_colours = dbg.success + col_colours
                        except KeyError:
                            pass

                        try:
                            colours = param["colours"]
                            if colours > 0:
                                col_colours = _list_colours(colours, control)
                        except KeyError:
                            pass

                        _add_row()

        print_columns(rows, True)

# After using a --list-* parameter, exit here as devices won't be manipulated.
if args.list_devices or args.list_options:
    exit()


########################################
# Determine devices and zones to change.
########################################
target_devices = []
target_zones = []

if args.zone and not args.zone == "all":
    target_zones = [args.zone]

if args.serial:
    for device in device_list:
        if device["serial"] == args.serial:
            target_devices.append(device)
            break

    if len(target_devices) == 0:
        dbg.stdout("Cannot find a device with serial " + args.serial, dbg.error)
        exit(1)

    target_devices = [device]

elif args.device == "all" or not args.device:
    target_devices = device_list

else:
    for device in device_list:
        if device["form_factor_id"] == args.device:
            target_devices.append(device)

if len(target_devices) == 0:
    dbg.stdout(_("No specified devices found."), dbg.error)
    exit(1)


# Quit if a device is selected, but there is nothing to do.
if not args.effect \
    and not args.game_mode \
    and not args.dpi \
    and not args.poll_rate \
    and not args.brightness:
        dbg.stdout(_("Please specify an action to perform."), dbg.warning)
        exit(1)


########################################
# Update device state
########################################
for device in target_devices:
    if not device["available"]:
        continue

    zones = target_zones
    if len(target_zones) == 0:
        zones = device["zones"]

    details = middleman.get_device(device["backend"], device["uid"])

    for zone in zones:
        # Brightness
        if args.brightness:
            status = middleman.set_device_state(device["backend"], device["uid"], "brightness", zone, [], [int(args.brightness)])
            if status == False:
                dbg.stdout(_("Failed to set brightness for [].").replace("[]", device["name"]), dbg.error)
            elif type(status) == str:
                dbg.stdout(_("Request failed. Here's the exception details:"), dbg.error)
                dbg.stdout(status)

        # Effect
        if args.effect:
            effect = args.effect
            effect_params = []

            # Validate request is possible
            try:
                details["zone_supported"][zone][effect]
            except KeyError:
                dbg.stdout(_("[name]: '[fx]' effect not supported in zone '[zone]'")
                    .replace("[name]", details["name"])
                    .replace("[fx]", effect)
                    .replace("[zone]", zone), dbg.warning)
                continue

            # Determine parameters
            # TODO: Read 'zone_states' when params unspecified.

            if effect == "wave":
                if args.wave_direction:
                    direction = {
                        "right": 1,     # Right / Up / Clockwise
                        "left": 2       # Left / Down / Anti-clockwise
                    }
                    effect_params = [direction[args.wave_direction]]
                else:
                    # Default
                    effect_params = [1]

            if effect == "reactive":
                if args.reactive_speed:
                    speed = {
                        "fast": 1,
                        "medium": 2,
                        "slow": 3,
                        "vslow": 4
                    }
                    effect_params = [speed[args.reactive_speed]]
                else:
                    # Default
                    effect_params = [2]

            if effect == "breath":
                if args.breath_type:
                    effect = "breath_" + args.breath_type
                else:
                    # Default
                    effect = "breath_single"

            if effect == "ripple":
                if args.ripple_type:
                    effect = "ripple_" + args.ripple_type
                else:
                    # Default
                    effect = "ripple_single"

                if args.ripple_speed:
                    effect_params = [args.ripple_speed]
                else:
                    effect_params = [0.01]

            if effect == "starlight":
                if args.starlight_type:
                    effect = "starlight_" + args.starlight_type
                else:
                    # Default
                    effect = "starlight_single"

            # Determine and validate colours
            colours = []
            for hex_value in [args.rgb, args.rgb2, args.rgb3]:
                if hex_value:
                    try:
                        common.hex_to_rgb(hex_value)
                    except ValueError:
                        dbg.stdout(_("Invalid 6 digit hex colour: []").replace("[]", args.rgb), dbg.error)
                        exit(1)
                colours.append(hex_value)

            status = middleman.set_device_state(device["backend"], device["uid"], effect, zone, colours, effect_params)

            if status == False:
                dbg.stdout(_("Failed to set '[fx]' effect for [name].")
                    .replace("[name]", device["name"])
                    .replace("[fx]", effect), dbg.error)
            elif type(status) == str:
                dbg.stdout(_("Request failed. Here's the exception details:"), dbg.error)
                dbg.stdout(status)

    # Game Mode
    if args.game_mode:
        if details["game_mode"] == None:
            continue

        state = {
            "on": True,
            "off": False
        }
        state = state[args.game_mode]

        status = middleman.set_device_state(device["backend"], device["uid"], "game_mode", "main", [], [state])

        if status == False:
            dbg.stdout(_("Failed to change for [name].").replace("[name]", device["name"]), dbg.error)
        elif type(status) == str:
            dbg.stdout(_("Request failed. Here's the exception details:"), dbg.error)
            dbg.stdout(status)
        elif status == True:
            if state == True:
                dbg.stdout(_("Game mode /enabled\ for [name]")
                    .replace("[name]", device["name"])
                    .replace("/", dbg.success)
                    .replace("\\", dbg.normal))
            else:
                dbg.stdout(_("Game mode /disabled\ for [name]")
                    .replace("[name]", device["name"])
                    .replace("/", dbg.error)
                    .replace("\\", dbg.normal))

    # DPI
    if args.dpi:
        if details["dpi_x"] == None:
            continue

        # Custom X and Y can be specified by adding a comma
        dpi = args.dpi
        if dpi.find(",") > 0:
            dpi_x = dpi.split(",")[0]
            dpi_y = dpi.split(",")[1]
        else:
            dpi_x = dpi
            dpi_y = dpi

        # Validate DPI is not too low
        for value in [dpi_x, dpi_y]:
            if int(value) < min_dpi:
                dbg.stdout(_("DPI too low: [x]").replace("[x]", value), dbg.error)
                continue

        status = middleman.set_device_state(device["backend"], device["uid"], "dpi", "main", [], [dpi_x, dpi_y])

        if status == False:
            dbg.stdout(_("Failed to set DPI for [name].").replace("[name]", device["name"]), dbg.error)
        elif type(status) == str:
            dbg.stdout(_("Request failed. Here's the exception details:"), dbg.error)
            dbg.stdout(status)
        elif status == True:
            dbg.stdout(_("DPI set to [x] for [name]").replace("[name]", device["name"]).replace("[x]", "{0},{1}".format(dpi_x, dpi_y)), dbg.success)

    # Poll Rate
    if args.poll_rate:
        if details["poll_rate"] == None:
            continue

        status = middleman.set_device_state(device["backend"], device["uid"], "poll_rate", "main", [], [args.poll_rate])

        if status == False:
            dbg.stdout(_("Failed to set poll rate for [name].").replace("[name]", device["name"]), dbg.error)
        elif type(status) == str:
            dbg.stdout(_("Request failed. Here's the exception details:"), dbg.error)
            dbg.stdout(status)
        elif status == True:
            dbg.stdout(_("Poll rate set to [x] Hz for [name]").replace("[name]", device["name"]).replace("[x]", args.poll_rate), dbg.success)
