#!/usr/bin/python3
#
# Polychromatic is free software: you can redistribute it and/or modify
# it under the temms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Polychromatic is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Polychromatic. If not, see <http://www.gnu.org/licenses/>.
#
# Copyright (C) 2015-2016 Terry Cain <terry@terrys-home.co.uk>
#               2015-2020 Luke Horwell <code@horwell.me>
#
"""
Control devices from the desktop environment's indicator applet or system tray.

Powered by AppIndicator (GTK) or GTK Status Icon.
"""
import argparse
import os
import sys
import signal
import setproctitle
from subprocess import Popen as background_process
from subprocess import call as foreground_process
from shutil import which

import gi
gi.require_version("Gtk", "3.0")
gi.require_version("Gdk", "3.0")
from gi.repository import Gtk, Gdk

try:
    gi.require_version("AppIndicator3", "0.1")
    from gi.repository import AppIndicator3 as appindicator
    indicator_support = True
except:
    indicator_support = False

VERSION = "0.6.0"

# Import modules if running relatively.
if os.path.exists(os.path.dirname(__file__) + "/pylib/"):
    try:
        import pylib.preferences as pref
        import pylib.common as common
        import pylib.locales as locales
        import pylib.middleman as middleman_mod
    except (ImportError, Exception) as e:
        print("Failed to import modules relatively.\n")
        raise e

# Import modules if installed system-wide.
else:
    try:
        import polychromatic.preferences as pref
        import polychromatic.common as common
        import polychromatic.locales as locales
        import polychromatic.middleman as middleman_mod
    except (ImportError, Exception) as e:
        print("Polychromatic's modules could not be imported.")
        print("Check all dependencies are installed, the Python environment variables are correct, or try re-installing the application.\n")
        print(str(e))
        exit(1)

path = pref.Paths()

def create_menu_item(label, enabled, function=None, function_params=None, icon_path=None):
    """
    Returns a Gtk menu item for use in menus.

    Params:
        label               (str)   Text to display to the user.
        enabled             (bool)  Whether the selection should be highlighted or not.
        function            (obj)   Callback when button is clicked.
        function_params     (obj)   Functions to pass the callback function.
        icon_path           (str)   Path to image file.
    """
    if icon_path and os.path.exists(icon_path):
        item = Gtk.ImageMenuItem(label=label)
        item.set_sensitive(enabled)
        item.show()

        img = Gtk.Image()
        img.set_from_file(icon_path)
        item.set_image(img)
    else:
        item = Gtk.MenuItem(label=label)
        item.set_sensitive(enabled)
        item.show()

    if function and not function_params:
        item.connect("activate", function)
    elif function and function_params:
        item.connect("activate", function, function_params)

    return item

def create_submenu_item(submenu, label, enabled, function=None, function_params=None, icon_path=None):
    """
    Appends a Gtk menu item to a submenu list.
        submenu             lst     Submenu created by create_submenu()
        <inherits create_menu_item parameters>
    """
    submenu[1].append(create_menu_item(label, enabled, function, function_params, icon_path))
    return

def create_submenu(label, enabled, icon_path=None):
    """
    Returns a Gtk menu item for sub-menu options.
        label               str     Text to display to the user.
        enabled             bool    Whether the selection should be highlighted or not.

    Returns list of objects:
        item                MenuItem (for parent menu)
        menu                Menu (containing child menu items)
    """
    if icon_path and os.path.exists(icon_path):
        item = Gtk.ImageMenuItem(label=label)
        item.set_sensitive(enabled)
        item.show()

        img = Gtk.Image()
        img.set_from_file(icon_path)
        item.set_image(img)            # GTK3: Deprecated, no replacement!
    else:
        item = Gtk.MenuItem(label=label)
        item.set_sensitive(enabled)
        item.show()

    menu = Gtk.Menu()
    menu.show()
    item.set_submenu(menu)

    return[item, menu]

def create_seperator():
    """
    Returns a Gtk seperator object.
    """
    sep = Gtk.SeparatorMenuItem()
    sep.show()
    return sep

def get_icon(img_dir, icon):
    """
    Returns the path for a Polychromatic icon.
        img_dir = Folder inside "ui/img", e.g. "effects"
        icon    = Filename excluding the extension.
    """
    icon_path = os.path.join(common.DATA_PATH, "ui" ,"img", img_dir, icon + ".svg")
    if os.path.exists(icon_path):
        return icon_path


class AppIndicator(object):
    """
    Indicator applet that provides quick access to device options from the system tray.
    """
    def __init__(self):
        self.indicator = None

    def setup(self):
        """
        Assemble the tray applet powered by AppIndicator or GTK Status Icon.
        """
        if pref.get("tray", "force_legacy_gtk_status") == True:
            global indicator_support
            indicator_support = False

        # Create an indicator or status icon depending on support.
        if indicator_support:
            self.indicator = appindicator.Indicator.new("polychromatic-tray-applet", self._get_tray_icon(), appindicator.IndicatorCategory.APPLICATION_STATUS)
            self.indicator.set_status(appindicator.IndicatorStatus.ACTIVE)
            dbg.stdout(_("Initialised AppIndicator."), dbg.success, 1)
        else:
            self.indicator = Gtk.StatusIcon()
            self.indicator.set_name("polychromatic-tray-applet")
            self.indicator.set_from_file(self._get_tray_icon())
            self.indicator.set_visible(True)
            dbg.stdout(_("Initialised GTK Status Icon (fallback)."), dbg.success, 1)

        # Output error if backends
        if len(middleman.backends) == 0:
            self._setup_failed(_("No backends available"), _("Please check the installation and try again"))
            return False

        # Build the applet
        self.build_indicator()
        dbg.stdout("Finished setting up applet.", dbg.success, 1)

        # TODO: Reload list on device changes

    def _get_tray_icon(self):
        """
        Returns path for tray icon.
        """
        return common.get_tray_icon(dbg, pref)

    def _show_menu_cb(self, widget, button, time, data=None):
        """
        Shows the non-indicator "legacy" implementation of the menu.
        """
        self.menu.show_all()
        self.menu.popup(None, None, Gtk.StatusIcon.position_menu, self.indicator, button, time)

    def _setup_failed(self, error_reason, exception=None):
        """
        A simple menu is displayed when something goes wrong.
        """
        dbg.stdout("Assembling error applet...", dbg.action, 1)
        root = Gtk.Menu()
        root.append(create_menu_item(error_reason, False))
        if exception:
            root.append(create_menu_item(_("Exception:") + ' ' + exception, False))
        root.append(create_seperator())
        root.append(create_menu_item(_("Refresh"), True, cb.retry_applet, None, get_icon("general", "refresh")))
        root.append(create_menu_item(_("Troubleshoot"), True, cb.launch_controller, "troubleshoot", get_icon("general", "preferences")))
        root.append(create_seperator())
        root.append(create_menu_item(_("Open Controller"), True, cb.launch_controller, None, get_icon("general", "controller")))
        root.append(create_menu_item(_("Quit"), True, cb.quit))

        if indicator_support:
            self.indicator.set_title("Polychromatic")
            self.indicator.set_icon(get_icon("tray", "error"))
            self.indicator.set_menu(root)
        else:
            self.indicator.set_from_file(get_icon("tray", "error"))
            self.menu = root
            self.indicator.connect("popup-menu", self._show_menu_cb)

        dbg.stdout("ERROR: " + error_reason, dbg.error)
        if exception:
            dbg.stdout("Exception: " + exception, dbg.error)

    def build_indicator(self):
        """
        Populates the menu for the tray applet.
        """
        # Load the tray icon
        if indicator_support:
            self.indicator.set_icon_full(self._get_tray_icon(), _("Polychromatic Lighting Menu"))
        else:
            self.indicator.set_from_file(self._get_tray_icon())

        dbg.stdout("Loading device data...", dbg.action, 1)
        devices = middleman.get_device_all()

        dbg.stdout("Creating menus...", dbg.action, 1)
        root = Gtk.Menu()

        # List devices and their submenus.
        if len(devices) == 0:
            dbg.stdout("No devices found.", dbg.error, 1)
            root.append(create_menu_item(_("No devices found."), False))
            root.append(create_seperator())
            root.append(create_menu_item(_("Refresh"), True, cb.retry_applet, None, get_icon("general", "refresh")))
            root.append(create_menu_item(_("Troubleshoot"), True, cb.launch_controller, "troubleshoot", get_icon("general", "preferences")))

        for device in devices:
            root.append(self.build_device_submenu(device)[0])

        # When multiple devices are present, show 'apply to all' actions
        if len(devices) > 1:
            root.append(create_seperator())

            # -- Effects






        # General Options
        root.append(create_seperator())
        root.append(create_menu_item(_("Open Controller"), True, cb.launch_controller, None, get_icon("general", "controller")))
        root.append(create_menu_item(_("Quit"), True, cb.quit))

        # Finalise tray applet.
        if indicator_support:
            self.indicator.set_title("Polychromatic")
            self.indicator.set_menu(root)
        else:
            self.menu = root
            self.indicator.connect("popup-menu", self._show_menu_cb)

    def build_device_submenu(self, device):
        """
        Assembles the menu (and submenus) that control an individual device_item.
        """
        backend = device["backend"] # FIXME unused?
        uid = device["uid"] # FIXME unused?
        device_name = device["name"]
        device_icon = device["form_factor"]["icon"]
        multiple_zones = len(device["zone_options"]) > 1
        can_set_colours = False

        submenu = create_submenu(device_name, True, device_icon)
        dbg.stdout("- " + device_name, dbg.action, 1)

        for zone in device["zone_options"].keys():
            zone_name = locales.get(zone)
            zone_icon = os.path.join(common.DATA_PATH, device["zone_icons"][zone])

            # Create label when multiple zones are present
            if multiple_zones:
                submenu[1].append(create_menu_item(zone_name, False, None, None, zone_icon))

            # Add options
            for option in device["zone_options"][zone]:
                option_id = option["id"]
                option_label = locales.get(option_id)
                option_icon = get_icon("options", option_id)

                # Show 'Edit Colours' later if supported
                if option["colours"] > 0:
                    can_set_colours = True

                # Option contains parameters, show submenu
                if option["type"] in ["effect", "multichoice"]:
                    # Option does not accept parameters, just a button
                    if len(option["parameters"]) == 0:
                        submenu[1].append(create_menu_item(option_label, True, cb.set_option, [device, zone, option_id, None], option_icon))
                    else:
                        # Create a submenu for effects
                        submenu[1].append(self.create_parameters_menu(device, zone, option)[0])

                        for param in option["parameters"]:
                            if param["colours"] > 0:
                                can_set_colours = True

                # Option is a slider, for values between 0 and 100.
                elif option["type"] == "slider":
                    submenu[1].append(self.create_slider_menu(device, zone, option)[0])

                elif option["type"] == "toggle":
                    submenu[1].append(self.create_toggle_menu(device, zone, option)[0])

            # Add DPI
            if zone == "main" and device["dpi_x"]:
                dpi_menu = create_submenu(_("DPI"), True, get_icon("general", "dpi"))
                for item, dpi in enumerate(device["dpi_ranges"]):
                    icon = None
                    if item == 0:
                        icon = get_icon("general", "dpi-slow")
                    elif item == 5:
                        icon = get_icon("general", "dpi-fast")
                    create_submenu_item(dpi_menu, str(dpi), True, cb.set_dpi, [device, dpi], icon)
                submenu[1].append(dpi_menu[0])

            # Create seperator if there was a zone label
            if multiple_zones:
                submenu[1].append(create_seperator())

        if device["matrix"]:
            submenu[1].append(create_seperator())

            #TODO: Add custom effects menu
            create_submenu_item(submenu, _("Effects not yet implemented"), False)

            submenu[1].append(create_seperator())
            create_submenu_item(submenu, _("Edit Effects..."), True, cb.launch_controller, "effects", get_icon("general", "edit"))

        # Colour (repeats last effect)
        if can_set_colours:
            colour_menu = create_submenu(_("Change Colour"), True, get_icon("general", "palette"))

            if device["monochromatic"]:
                col_index = common.get_green_shades()
            else:
                col_index = pref.load_file(path.colours)

            for pos in range(0, len(col_index)):
                try:
                    name = col_index[pos]["name"]
                    hex_value = col_index[pos]["hex"]
                    create_submenu_item(colour_menu, name, True, cb.set_colour, [backend, uid, zone, hex_value], self._get_colour_icon(hex_value))
                except Exception:
                    dbg.stdout("Ignoring invalid colour data at index position " + str(pos), dbg.error)

            colour_menu[1].append(create_seperator())
            create_submenu_item(colour_menu, _("Custom..."), True, cb.set_custom_colour, [backend, uid, zone], get_icon("general", "palette"))
            create_submenu_item(colour_menu, _("Edit Colours..."), True, cb.launch_controller, "colours", get_icon("general", "edit"))
            submenu[1].append(create_seperator())
            submenu[1].append(colour_menu[0])

        return submenu

    def create_parameters_menu(self, device, zone, option):
        """
        Creates the submenu for an option containing parameters from a multiple
        choice or effect list.
        """
        option_id = option["id"]
        submenu = create_submenu(locales.get(option_id), True, get_icon("options", option_id))

        for param in option["parameters"]:
            param_id = param["id"]
            param_data = param["data"]

            # Some IDs have submenu icons
            icon = None

            create_submenu_item(submenu, locales.get(param_id), True, cb.set_option, [device, zone, option_id, param_data], icon)

        return submenu

    def create_slider_menu(self, device, zone, option):
        """
        Creates the submenu for an option that is a variable slider. This will
        create five calculated intervals (e.g. 0-100 -> 0,25,50,75,100)
        """
        option_id = option["id"]
        submenu = create_submenu(locales.get(option_id), True, get_icon("options", option_id))

        suffix = option["suffix"]
        min = int(option["min"])
        max = int(option["max"])
        interval = int((max - min) / 4)
        for no in range(max, min - interval, 0 - interval):
            # Some IDs have submenu icons
            icon = None
            if option_id == "brightness":
                icon = get_icon("options", str(no))

            create_submenu_item(submenu, str(no) + suffix, True, cb.set_option, [device, zone, option_id, int(no)], icon)

        return submenu

    def create_toggle_menu(self, device, zone, option):
        """
        Creates the submenu for an option that is either on/off.
        """
        option_id = option["id"]
        submenu = create_submenu(locales.get(option_id), True, get_icon("options", option_id))

        # Some IDs have submenu icons
        icon_on = None
        icon_off = None
        if option_id == "game_mode":
            icon_on = get_icon("options", "game_mode")
            icon_off = get_icon("options", "game_mode_disabled")
        elif option_id == "brightness":
            icon_on = get_icon("options", "100")
            icon_off = get_icon("options", "0")

        create_submenu_item(submenu, _("On"), True, cb.set_option, [device, zone, option_id, True], icon_on)
        create_submenu_item(submenu, _("Off"), True, cb.set_option, [device, zone, option_id, False], icon_off)

        return submenu

    def _get_colour_icon(self, colour_hex):
        """
        Generates a colour PNG, and returns the path so it can be used as an icon.

        Params:
            colour_hex      Hex value, e.g. "#00FF00"
        """
        colour_path = os.path.join(session_storage, "{0}.png".format(colour_hex.strip("#")))
        if not os.path.exists(colour_path):
            dbg.stdout("Generating colour bitmap: " + colour_hex, dbg.action, 1)
            foreground_process("convert -size 22x22 xc:{0} {1}".format(colour_hex, colour_path), shell=True)
        if not os.path.exists(colour_path):
            dbg.stdout("ERROR: Failed to generate bitmap: " + colour_hex, dbg.error)
            return None
        return colour_path


class Callback():
    """
    Contains functions that run when a menu item is clicked.
    """
    @staticmethod
    def launch_controller(item, tab=None):
        """
        GTK menu item callback to open the Controller application.

        Params:
            tab     (Optional) Open a specific tab in the Controller
        """
        if tab:
            dbg.stdout("=> Launching Controller to '{0}' tab/section...".format(tab), dbg.action, 1)
        else:
            dbg.stdout("=> Launching Controller...", dbg.action, 1)

        common.execute_polychromatic_component(dbg, "controller", tab)

    @staticmethod
    def quit(item):
        """
        GTK menu item callback to quit the application.
        """
        dbg.stdout("Exiting...", dbg.action, 1)
        exit(0)

    @staticmethod
    def retry_applet(item):
        """
        GTK menu item callback to restart the tray applet.
        """
        dbg.stdout("Restarting applet...", dbg.action, 1)
        os.execv(__file__, sys.argv)
        exit(0)

    @staticmethod
    def set_option(item, attr):
        """
        GTK menu item to set an effect for a device.

        Params:
            attr    [device, zone, option_id, option_data]
        """
        backend = attr[0]
        uid = attr[1]
        zone = attr[2]
        effect = attr[3]
        try:
            params = attr[4]
        except IndexError:
            params = None
        print("stub:cb.set_option")
        return

        dbg.stdout("Setting effect for {0} device ID {1} in zone '{2}' to '{3}'".format(backend, uid, zone, effect), dbg.debug, 1)
        r = middleman.set_device_state(backend, uid, effect, zone, None, [params])
        _verbose_check_status(r)

    @staticmethod
    def set_brightness(item, attr):
        """
        GTK menu item callback to set the brightness of a device.

        Params:
            attr    [uid, zone, value]
        """
        backend = attr[0]
        uid = attr[1]
        zone = attr[2]
        value = attr[3]

        dbg.stdout("Setting brightness for {0} device ID {1} in zone '{2}' to '{3}'".format(backend, uid, zone, value), dbg.debug, 1)
        r = middleman.set_device_state(backend, uid, "brightness", zone, None, [value])
        _verbose_check_status(r)

    @staticmethod
    def set_colour(item, attr):
        """
        GTK menu item callback to replay the current effect but use a different
        primary colour.

        Params:
            attr    [uid, zone, hex_string]
        """
        print("stub:cb.set_colour")
        return
        backend = attr[0]
        uid = attr[1]
        zone = attr[2]
        hex_value = attr[3]

        dbg.stdout("Setting colour for {0} device ID {1} in zone '{2}' to '{3}'".format(backend, uid, zone, hex_value), dbg.debug, 1)
        r = middleman.set_device_colours(backend, uid, zone, [hex_value])
        _verbose_check_status(r)

    @staticmethod
    def set_dpi(item, attr):
        """
        GTK menu item callback to set the DPI of a device.

        Params:
            attr    [device, dpi_x]
        """
        print("stub:cb.set_dpi")
        return
        backend = attr[0]
        uid = attr[1]
        new_dpi = attr[2]

        dbg.stdout("Setting DPI for {0} device ID {1} to '{2}'".format(backend, uid, new_dpi), dbg.debug, 1)
        r = middleman.set_device_state(backend, uid, "dpi", None, None, [new_dpi, new_dpi])
        _verbose_check_status(r)

    @staticmethod
    def set_all_effect(item, attr):
        """
        GTK menu item callback to set an effect for all devices (using defaults)

        Params:
            option_id       ID of effect to set
        """
        print("stub:set_all_effect")
        return
        request = attr[0]
        try:
            params = int(attr[1])
        except Exception:
            params = None

        devices = middleman.get_device_list()
        dbg.stdout("Setting all devices to '{0}'".format(request), dbg.debug, 1)

        for device in devices:
            if device["available"] == True:
                zones = device["zones"]
                for zone in zones:
                    dbg.stdout("- {0} [{1}]".format(device["name"], zone), dbg.action, 1)
                    r = middleman.set_device_state(device["backend"], int(device["uid"]), request, zone, None, [params])
                    _verbose_check_status(r)

    @staticmethod
    def set_all_brightness(item, value):
        """
        GTK menu item callback to set the brightness for all devices (or
        on/off if unsupported)

        Params:
            value           String representing brightness %
        """
        print("stub:set_all_brightness")
        return
        value = int(value)

        devices = middleman.get_device_list()
        dbg.stdout("Setting all brightness levels to {0}%".format(str(value)), dbg.debug, 1)

        for device in devices:
            if device["available"] == True:
                zones = device["zones"]
                for zone in zones:
                    dbg.stdout("- {0} [{1}]".format(device["name"], zone), dbg.action, 1)
                    r = middleman.set_device_state(device["backend"], device["uid"], "brightness", zone, None, [value])
                    _verbose_check_status(r)

    @staticmethod
    def set_all_colour(item, value):
        """
        GTK menu item callback to set the primary colour for all supported devices.

        Params:
            value       (lst)   Hex value
        """
        dbg.stdout("Setting all device primary colour to {0}".format(value), dbg.debug, 1)
        print("stub:set_all_colour")
        return

        devices = middleman.get_device_list()
        for device in devices:
            if device["available"] == True:
                zones = device["zones"]
                for zone in zones:
                    dbg.stdout("- {0} [{1}]".format(device["name"], zone), dbg.action, 1)
                    r = middleman.set_device_colours(device["backend"], device["uid"], zone, value)
                    _verbose_check_status(r)

    @staticmethod
    def set_custom_colour(item, attr):
        """
        GTK menu item callback to open a GTK dialogue picker to change the colour
        of a device.

        Params:
            attr    [device object]
        """
        print("stub:set_custom_colour")
        return

        backend = attr[0]
        uid = attr[1]
        zone = attr[2]

        dbg.stdout("Opened GTK colour picker.", dbg.debug, 1)
        color_selection_dlg = Gtk.ColourSelectionDialog(_("Set Primary Colour"))
        color_selection_result = color_selection_dlg.run()

        if color_selection_result == Gtk.ResponseType.OK:
            result_gdk_colour = color_selection_dlg.get_color_selection().get_current_color()
            red = int(result_gdk_colour.red_float * 255)
            green = int(result_gdk_colour.green_float * 255)
            blue = int(result_gdk_colour.blue_float * 255)
            hex_value = common.rgb_to_hex([red, green, blue])

            dbg.stdout("Set custom colour for {0} device ID {1} to '{2}'".format(backend, uid, hex_value), dbg.debug, 1)
            r = middleman.set_device_colours(backend, uid, zone, [hex_value])
            _verbose_check_status(r)

        color_selection_dlg.destroy()


def _verbose_check_status(result):
    """
    When using the verbose parameter (-v), output details if a request made
    to the backend was successful.
    """
    if type(result) == str:
        dbg.stdout("An exception occurred processing this request:", dbg.error)
        dbg.stdout(result, dbg.error)
    elif result == True:
        dbg.stdout("Request OK", dbg.success, 1)
    elif result == None:
        dbg.stdout("Device Missing", dbg.warning, 1)
    elif result == False:
        dbg.stdout("Request unsuccessful - may be unsupported by the device.", dbg.normal, 1)


def parse_parameters():
    """
    Parses the optional parameters for the tray applet.
    """
    global _
    parser = argparse.ArgumentParser(add_help=False)
    parser._optionals.title = _("Optional arguments")
    parser.add_argument("-h", "--help", help=_("Show this help message and exit"), action="help")
    parser.add_argument("-v", "--verbose", help=_("Be verbose to stdout"), action="store_true")
    parser.add_argument("--locale", help=_("Force a specific locale, e.g. de_DE"), action="store")
    parser.add_argument("--force-fallback", help=_("Force GTK Status Icon instead of AppIndicator"), action="store_true")

    args = parser.parse_args()

    if args.verbose:
        dbg.verbose_level = 1
        dbg.stdout(_("Verbose enabled"), dbg.debug, 1)

    if args.locale:
        _ = locales.reload_locales(locales, __file__, args.locale)

    if args.force_fallback:
        global indicator_support
        indicator_support = False


if __name__ == "__main__":
    # Appear as its own process.
    setproctitle.setproctitle("polychromatic-tray-applet")

    # Global variables
    path = pref.Paths()
    _ = locales._
    dbg = common.Debugging()

    # Kill the process when CTRL+C'd.
    signal.signal(signal.SIGINT, signal.SIG_DFL)

    # Prepare cache directory
    session_storage = os.path.join(path.cache, "tray")
    if not os.path.exists(session_storage):
        os.makedirs(session_storage)

    parse_parameters()

    # Initalise devices
    middleman = middleman_mod.Middleman(dbg, common)
    middleman.init()
    device_list = middleman.get_device_list()

    # Initialise the indicator
    cb = Callback()
    indicator = AppIndicator()
    indicator.setup()

    Gtk.main()
