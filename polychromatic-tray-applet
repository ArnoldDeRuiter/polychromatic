#!/usr/bin/env python3
# -*- coding:utf-8 -*-
#
# Polychromatic is free software: you can redistribute it and/or modify
# it under the temms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Polychromatic is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Polychromatic. If not, see <http://www.gnu.org/licenses/>.
#
# Copyright (C) 2015-2016 Terry Cain <terry@terrys-home.co.uk>
#               2015-2019 Luke Horwell <code@horwell.me>
#
"""
Control devices from the desktop environment's indicator applet or system tray.
"""
VERSION = "0.5.0"

import argparse
import os
import sys
import signal
from setproctitle import setproctitle
from subprocess import Popen as background_process
from subprocess import call as foreground_process
from shutil import which

import gi
gi.require_version("Gtk", "3.0")
gi.require_version("Gdk", "3.0")
from gi.repository import Gtk, Gdk

try:
    gi.require_version("AppIndicator3", "0.1")
    from gi.repository import AppIndicator3 as appindicator
    indicator_support = True
except:
    indicator_support = False

# Import modules if running relatively.
if os.path.exists(os.path.dirname(__file__) + "/pylib/"):
    try:
        import pylib.preferences as pref
        import pylib.common as common
        from pylib.backends import openrazer
    except (ImportError, Exception) as e:
        print("Failed to import modules relatively.\n")
        raise e

# Import modules if installed system-wide.
else:
    try:
        import polychromatic.preferences as pref
        import polychromatic.common as common
        from polychromatic.backends import openrazer
    except (ImportError, Exception) as e:
        print("Polychromatic's modules could not be imported.")
        print("Check all dependencies are installed, the Python environment variables are correct, or try re-installing the application.\n")
        print(str(e))
        exit(1)

path = pref.Paths()

def create_menu_item(label, enabled, function=None, function_params=None, icon_path=None):
    """
    Returns a Gtk menu item for use in menus.

    Params:
        label               str     Text to display to the user.
        enabled             bool    Whether the selection should be highlighted or not.
        function            obj     Callback when button is clicked.
        function_params     obj     Functions to pass the callback function.
        icon_path           str     Path to image file.
    """
    if icon_path and os.path.exists(icon_path):
        item = Gtk.ImageMenuItem(label=label)
        item.set_sensitive(enabled)
        item.show()

        img = Gtk.Image()
        img.set_from_file(icon_path)
        item.set_image(img)
    else:
        item = Gtk.MenuItem(label=label)
        item.set_sensitive(enabled)
        item.show()

    if function and not function_params:
        item.connect("activate", function)
    elif function and function_params:
        item.connect("activate", function, function_params)

    return item


def create_submenu_item(submenu, label, enabled, function=None, function_params=None, icon_path=None):
    """
    Appends a Gtk menu item to a submenu list.
        submenu             lst     Submenu created by create_submenu()
        <inherits create_menu_item parameters>
    """
    submenu[1].append(create_menu_item(label, enabled, function, function_params, icon_path))
    return

def create_submenu(label, enabled, icon_path=None):
    """
    Returns a Gtk menu item for sub-menu options.
        label               str     Text to display to the user.
        enabled             bool    Whether the selection should be highlighted or not.

    Returns list of objects:
        item                MenuItem (for parent menu)
        menu                Menu (containing child menu items)
    """
    if icon_path and os.path.exists(icon_path):
        item = Gtk.ImageMenuItem(label=label)
        item.set_sensitive(enabled)
        item.show()

        img = Gtk.Image()
        img.set_from_file(icon_path)
        item.set_image(img)            # GTK3: Deprecated, no replacement!
    else:
        item = Gtk.MenuItem(label=label)
        item.set_sensitive(enabled)
        item.show()

    menu = Gtk.Menu()
    menu.show()
    item.set_submenu(menu)

    return[item, menu]


def create_seperator():
    """
    Returns a Gtk seperator object.
    """
    sep = Gtk.SeparatorMenuItem()
    sep.show()
    return sep


def get_icon(img_dir, icon):
    """
    Returns the path for a Polychromatic icon.
        img_dir = Folder inside "ui/img", e.g. "effects"
        icon    = Filename, including extension.
    """
    return os.path.join(common.DATA_PATH, "ui/img/", img_dir, icon)


class AppIndicator(object):
    """
    Indicator applet that provides quick access to device options from the system tray.
    """
    def __init__(self):
        self.indicator = None

    def setup(self):
        """
        Assemble the tray applet powered by AppIndicator or GTKStatusIcon.
        """
        # User can optionally use 'legacy' GTK status icon.
        if pref.get("tray_icon", "force_fallback", False) == True:
            global indicator_support
            indicator_support = False

        # Create an indicator or status icon depending on support.
        if indicator_support:
            self.indicator = appindicator.Indicator.new("polychromatic-tray-applet", self._get_tray_icon(), appindicator.IndicatorCategory.APPLICATION_STATUS)
            self.indicator.set_status(appindicator.IndicatorStatus.ACTIVE)
            dbg.stdout(_("Initialised AppIndicator."), dbg.success, 1)
        else:
            self.indicator = Gtk.StatusIcon()
            self.indicator.set_name("polychromatic-tray-applet")
            self.indicator.set_from_file(self._get_tray_icon())
            self.indicator.set_visible(True)
            dbg.stdout(_("Initialised GTK Status Icon (fallback)."), dbg.success, 1)

        # Check OpenRazer is installed.
        if not which("openrazer-daemon"):
            self._setup_failed(_("OpenRazer Module Missing"), _("Unknown command: openrazer-daemon"))
            return False

        # Build the applet
        self.build_indicator()
        dbg.stdout("Finished setting up applet.", dbg.success, 1)

        # TODO: DBUS listening

    def _get_tray_icon(self):
        """
        Returns path for tray icon.
        """
        return common.get_tray_icon(dbg, pref)

    def _show_menu_cb(self, widget, button, time, data=None):
        """
        Shows the non-indicator "legacy" implementation of the menu.
        """
        self.menu.show_all()
        self.menu.popup(None, None, Gtk.StatusIcon.position_menu, self.indicator, button, time)

    def _setup_failed(self, error_reason, exception=None):
        """
        A simple menu is displayed when something goes wrong.
        """
        dbg.stdout("Assembling error applet...", dbg.action, 1)
        root = Gtk.Menu()
        root.append(create_menu_item(error_reason, False))
        root.append(create_menu_item(_("Exception:") + ' ' + exception, False))
        root.append(create_seperator())
        root.append(create_menu_item(_("Try again"), True, cb.retry_applet, None, get_icon("fa", "refresh.svg")))
        root.append(create_menu_item(_("Troubleshoot"), True, cb.launch_controller, "troubleshoot", get_icon("fa", "preferences.svg")))
        root.append(create_menu_item(_("Restart OpenRazer Daemon"), True, cb.restart_daemon, None, get_icon("logo", "openrazer-alt.svg")))
        root.append(create_seperator())
        root.append(create_menu_item(_("Open Controller"), True, cb.launch_controller, None, get_icon("general", "controller.svg")))
        root.append(create_menu_item(_("Quit"), True, cb.quit))

        if indicator_support:
            self.indicator.set_title("Polychromatic")
            self.indicator.set_icon(get_icon("../../tray/", "error.svg"))
            self.indicator.set_menu(root)
        else:
            self.indicator.set_from_file(get_icon("../../tray/", "error.svg"))
            self.menu = root
            self.indicator.connect("popup-menu", self._show_menu_cb)

        dbg.stdout("ERROR: " + error_reason, dbg.error)
        if exception:
            dbg.stdout("Exception: " + exception, dbg.error)

    def build_indicator(self):
        """
        Populates the menu for the tray applet.
        """
        # Load the tray icon
        if indicator_support:
            self.indicator.set_icon_full(self._get_tray_icon(), _("Icon that represents Razer devices"))
        else:
            self.indicator.set_from_file(self._get_tray_icon())

        dbg.stdout("Creating menus...", dbg.action, 1)
        root = Gtk.Menu()

        devices = openrazer.get_device_list()
        apply_all_may_not_work = False

        # List devices and their submenus.
        if len(devices) == 0:
            dbg.stdout("No devices found.", dbg.error, 1)
            root.append(create_menu_item(_("No devices found."), False))
            root.append(create_seperator())
            root.append(create_menu_item(_("Try again"), True, cb.retry_applet, None, get_icon("fa", "refresh.svg")))
            root.append(create_menu_item(_("Troubleshoot"), True, cb.launch_controller, "troubleshooter", get_icon("fa", "preferences.svg")))
            root.append(create_menu_item(_("Restart OpenRazer Daemon"), True, cb.restart_daemon, None, get_icon("logo", "openrazer-alt.svg")))
        else:
            for device in devices:
                if not device["available"]:
                    dbg.stdout("{0} is not registered by the OpenRazer daemon.".format(device["name"]), dbg.warning, 1)
                    root.append(create_menu_item("{0}: {1}".format(_("Unrecognized"), device["name"]), False, None, None, device["icon"]))
                    continue

                # Get full details about this device and build its submenu.
                details = openrazer.get_device(device["uid"])
                root.append(self.build_device_submenu(device, details)[0])

                for zone in details["zone_supported"].keys():
                    try:
                        for fx in ["spectrum", "wave", "breath", "reactive", "static"]:
                            details["zone_supported"][zone][fx]
                    except KeyError:
                        apply_all_may_not_work = True

        # When multiple devices are present, show 'apply to all' actions
        if len(devices) > 1:
            root.append(create_seperator())
            bulk_submenu = create_submenu(_("Apply to All"), True, get_icon("devices", "all.svg"))

            # -- Effects
            create_submenu_item(bulk_submenu, _("Effects"), False)

            if apply_all_may_not_work:
                create_submenu_item(bulk_submenu, _("(Not supported by all devices)"), False)

            create_submenu_item(bulk_submenu, _("Spectrum"), True, cb.set_all_effect, ["spectrum"], get_icon("effects", "spectrum.svg"))
            create_submenu_item(bulk_submenu, _("Wave"), True, cb.set_all_effect, ["wave", 1], get_icon("effects", "wave.svg"))
            create_submenu_item(bulk_submenu, _("Breath"), True, cb.set_all_effect, ["breath_single"], get_icon("effects", "breath.svg"))
            create_submenu_item(bulk_submenu, _("Reactive"), True, cb.set_all_effect, ["reactive", 1], get_icon("effects", "reactive.svg"))
            create_submenu_item(bulk_submenu, _("Static"), True, cb.set_all_effect, ["static"], get_icon("effects", "static.svg"))

            # -- Brightness
            bulk_submenu[1].append(create_seperator())
            create_submenu_item(bulk_submenu, _("Brightness"), False)
            create_submenu_item(bulk_submenu, " 100% / " + _("On"), True, cb.set_all_brightness, "100", get_icon("brightness", "100.svg"))
            create_submenu_item(bulk_submenu, " 75%", True, cb.set_all_brightness, "75", get_icon("brightness", "75.svg"))
            create_submenu_item(bulk_submenu, " 50%", True, cb.set_all_brightness, "50", get_icon("brightness", "50.svg"))
            create_submenu_item(bulk_submenu, " 25%", True, cb.set_all_brightness, "25", get_icon("brightness", "25.svg"))
            create_submenu_item(bulk_submenu, " 0% / " + _("Off"), True, cb.set_all_brightness, "0", get_icon("brightness", "0.svg"))

            root.append(bulk_submenu[0])

        # General Options
        root.append(create_seperator())
        root.append(create_menu_item(_("Open Controller"), True, cb.launch_controller, None, get_icon("general", "controller.svg")))
        root.append(create_menu_item(_("Quit"), True, cb.quit))

        # Finalise tray applet.
        if indicator_support:
            self.indicator.set_title("Polychromatic")
            self.indicator.set_menu(root)
        else:
            self.menu = root
            self.indicator.connect("popup-menu", self._show_menu_cb)

    def build_device_submenu(self, device, details):
        """
        Assembles the menu (and submenus) that control an individual device.
        """
        cb = Callback()
        submenu = create_submenu(details["name"], True, details["icon"])
        dbg.stdout("- {0}".format(details["name"]), dbg.action, 1)

        uid = device["uid"]
        multiple_zones = False
        if len(device["zones"]) > 1:
            multiple_zones = True


        for zone in device["zones"]:
            if multiple_zones:
                submenu[1].append(create_menu_item(details["zone_names"][zone], False, None, None, details["zone_icons"][zone]))

            # Add effects menu
            if details["matrix"]:
                submenu[1].append(self._create_effect_submenu(details, zone)[0])

            # Add brightness menu
            if "brightness_slider" in details["zone_supported"][zone].keys():
                submenu[1].append(self._create_brightness_submenu(details, zone, False)[0])

            if "brightness_toggle" in details["zone_supported"][zone].keys():
                submenu[1].append(self._create_brightness_submenu(details, zone, True)[0])

            # End of zone-specific options
            if multiple_zones:
                submenu[1].append(create_seperator())

        # Game Mode
        if details["game_mode"] != None:
            dbg.stdout("  - Game Mode", dbg.debug, 1)
            game_mode_menu = create_submenu(_("Game Mode"), True, get_icon("general", "game-mode.svg"))
            create_submenu_item(game_mode_menu, _("On"), True, cb.set_game_mode, [uid, True], get_icon("general", "game-mode.svg"))
            create_submenu_item(game_mode_menu, _("Off"), True, cb.set_game_mode, [uid, False], get_icon("general", "game-mode-disabled.svg"))
            submenu[1].append(game_mode_menu[0])

        # DPI
        if details["dpi_x"] != None:
            dbg.stdout("  - DPI", dbg.debug, 1)
            dpi_menu = create_submenu(_("DPI"), True, get_icon("general", "dpi.svg"))
            dpi_range = details["dpi_ranges"]
            min_dpi = dpi_range[0]
            max_dpi = dpi_range[-1]

            for dpi in dpi_range:
                if dpi == min_dpi:
                    dpi_icon = get_icon("general", "dpi-slow.svg")
                elif dpi == max_dpi:
                    dpi_icon = get_icon("general", "dpi-fast.svg")
                else:
                    dpi_icon = None
                create_submenu_item(dpi_menu, str(dpi), True, cb.set_dpi, [uid, int(dpi)], dpi_icon)
            submenu[1].append(dpi_menu[0])

        # Polling Rate
        if details["poll_rate"] != None:
            dbg.stdout("  - Poll Rate", dbg.debug, 1)
            poll_menu = create_submenu(_("Polling Rate"), True, get_icon("fa", "poll-rate.svg"))
            create_submenu_item(poll_menu, _("125 Hz (8ms)"), True, cb.set_poll_rate, [uid, 125])
            create_submenu_item(poll_menu, _("500 Hz (2ms)"), True, cb.set_poll_rate, [uid, 500])
            create_submenu_item(poll_menu, _("1000 Hz (1ms)"), True, cb.set_poll_rate, [uid, 1000])
            submenu[1].append(poll_menu[0])

        # Colour (repeats last effect)
        if details["matrix"]:
            dbg.stdout("  - Colours", dbg.debug, 1)
            colour_menu = create_submenu(_("Change Color"), True, get_icon("fa", "palette.svg"))

            if details["monochromatic"]:
                col_index = common.get_green_shades()
            else:
                col_index = pref.load_file(path.colours)

            for pos in range(0, len(col_index)):
                try:
                    name = col_index[pos]["name"]
                    hex_value = col_index[pos]["hex"]
                    create_submenu_item(colour_menu, name, True, cb.set_colour, [uid, zone, hex_value], self._get_colour_icon(hex_value))
                except Exception:
                    dbg.stdout("Ignoring invalid colour data at index position " + str(pos), dbg.error)

            colour_menu[1].append(create_seperator())
            create_submenu_item(colour_menu, _("Custom..."), True, cb.set_custom_colour, [uid, zone], get_icon("fa", "palette.svg"))
            create_submenu_item(colour_menu, _("Edit Colors..."), True, cb.launch_controller, ["colours"], get_icon("fa", "edit.svg"))
            submenu[1].append(create_seperator())
            submenu[1].append(colour_menu[0])

        return submenu

    def _create_effect_submenu(self, details, zone):
        """
        Builds an individual submenu that lists the device's effects.

        Params:
            zone      (str)   "main", "logo", etc
        """
        dbg.stdout("  - Effects [{0}]".format(zone), dbg.debug, 1)
        submenu = create_submenu(_("Effects"), True, get_icon("fa", "effects.svg"))
        supported_fx = details["zone_supported"][zone].keys()
        uid = details["uid"]

        if "spectrum" in supported_fx:
            create_submenu_item(submenu, _("Spectrum"), True, cb.set_effect, [uid, zone, "spectrum"], get_icon("effects", "spectrum.svg"))

        if "wave" in supported_fx:
            localised_directions = common.get_wave_direction(details["form_factor_id"])
            left = localised_directions[0]
            right = localised_directions[1]

            wave_menu = create_submenu(_("Wave"), True, get_icon("effects", "wave.svg"))
            create_submenu_item(wave_menu, left, True, cb.set_effect, [uid, zone, "wave", 2])
            create_submenu_item(wave_menu, right, True, cb.set_effect, [uid, zone, "wave", 1])
            submenu[1].append(wave_menu[0])

        if "reactive" in supported_fx:
            reactive_menu = create_submenu(_("Reactive"), True, get_icon("effects", "reactive.svg"))
            create_submenu_item(reactive_menu, _("Fast"), True, cb.set_effect, [uid, zone, "reactive", 1])
            create_submenu_item(reactive_menu, _("Medium"), True, cb.set_effect, [uid, zone, "reactive", 2])
            create_submenu_item(reactive_menu, _("Slow"), True, cb.set_effect, [uid, zone, "reactive", 3])
            create_submenu_item(reactive_menu, _("Very Slow"), True, cb.set_effect, [uid, zone, "reactive", 4])
            submenu[1].append(reactive_menu[0])

        if "breath" in supported_fx:
            breath_menu = create_submenu(_("Breath"), True, get_icon("effects", "breath.svg"))
            breath_supported = details["zone_supported"][zone]["breath_options"]

            if "random" in breath_supported:
                create_submenu_item(breath_menu, _("Random"), True, cb.set_effect, [uid, zone, "breath_random"])
            if "single" in breath_supported:
                create_submenu_item(breath_menu, _("Single"), True, cb.set_effect, [uid, zone, "breath_single"])
            if "dual" in breath_supported:
                create_submenu_item(breath_menu, _("Dual"), True, cb.set_effect, [uid, zone, "breath_dual"])
            if "triple" in breath_supported:
                create_submenu_item(breath_menu, _("Triple"), True, cb.set_effect, [uid, zone, "breath_triple"])

            submenu[1].append(breath_menu[0])

        if "starlight" in supported_fx:
            starlight_menu = create_submenu(_("Starlight"), True, get_icon("effects", "starlight.svg"))
            starlight_supported = details["zone_supported"][zone]["starlight_options"]

            if "random" in starlight_options:
                create_submenu_item(breath_menu, _("Random"), True, cb.set_effect, [uid, zone, "starlight_random"])
            if "single" in starlight_options:
                create_submenu_item(breath_menu, _("Single"), True, cb.set_effect, [uid, zone, "starlight_single"])
            if "dual" in starlight_options:
                create_submenu_item(breath_menu, _("Dual"), True, cb.set_effect, [uid, zone, "starlight_dual"])

            submenu[1].append(starlight_menu[0])

        if "blinking" in supported_fx:
            create_submenu_item(submenu, _("Blinking"), True, cb.set_effect, [uid, zone, "blinking"], get_icon("effects", "blinking.svg"))

        if "pulsate" in supported_fx:
            create_submenu_item(submenu, _("Pulsate"), True, cb.set_effect, [uid, zone, "pulsate"], get_icon("effects", "pulsate.svg"))

        if "ripple" in supported_fx:
            ripple_menu = create_submenu(_("Ripple"), True, get_icon("effects", "ripple.svg"))
            ripple_supported = details["zone_supported"][zone]["ripple_options"]

            # Use a submenu if device supports both ripple effects.
            if "random" in ripple_supported:
                create_submenu_item(ripple_menu, _("Single Color"), True, cb.set_effect, [uid, zone, "ripple_single", 0.01])
                create_submenu_item(ripple_menu, _("Random"), True, cb.set_effect, [uid, zone, "ripple_random", 0.01])
                submenu[1].append(ripple_menu[0])
            else:
                # Just support single colour ripple
                create_submenu_item(submenu, _("Ripple"), True, cb.set_effect, [uid, zone, "ripple_single"], get_icon("effects", "ripple.svg"))

        if "static" in supported_fx:
            create_submenu_item(submenu, _("Static"), True, cb.set_effect, [uid, zone, "static"], get_icon("effects", "static.svg"))

        if details["matrix"]:
            submenu[1].append(create_seperator())

            # TODO: Add custom effects menu
            create_submenu_item(submenu, _("No custom effects"), False)

            submenu[1].append(create_seperator())
            create_submenu_item(submenu, _("Edit Effects..."), True, cb.launch_controller, "effects", get_icon("fa", "edit.svg"))

        return submenu

    # Create brightness menu
    def _create_brightness_submenu(self, details, zone, toggle_only):
        """
        Builds an individual submenu for setting a device's brightness.

        zone          str     "main", "logo", etc
        toggle_only     bool    True if this should show "on/off" controls.
        """
        dbg.stdout("  - Brightness [{0}]".format(zone), dbg.debug, 1)
        submenu = create_submenu(_("Brightness"), True, get_icon("fa", "lightbulb.svg"))
        uid = details["uid"]

        if toggle_only:
            create_submenu_item(submenu, _("On"), True, cb.set_brightness, [uid, zone, 1], get_icon("brightness", "100.svg"))
            create_submenu_item(submenu, _("Off"), True, cb.set_brightness, [uid, zone, 0], get_icon("brightness", "0.svg"))
        else:
            for no in [100, 75, 50, 25, 0]:
                create_submenu_item(submenu, str(no) + "%", True, cb.set_brightness, [uid, zone, no], get_icon("brightness", str(no) + ".svg"))

        return submenu

    def _get_colour_icon(self, colour_hex):
        """
        Generates a colour PNG, and returns the path so it can be used as an icon.

        Params:
            colour_hex      Hex value, e.g. "#00FF00"
        """
        colour_path = os.path.join(session_storage, "{0}.png".format(colour_hex.strip("#")))
        if not os.path.exists(colour_path):
            dbg.stdout("Generating colour bitmap: " + colour_hex, dbg.action, 1)
            foreground_process("convert -size 22x22 xc:{0} {1}".format(colour_hex, colour_path), shell=True)
        if not os.path.exists(colour_path):
            dbg.stdout("ERROR: Failed to generate bitmap: " + colour_hex, dbg.error)
            return None
        return colour_path


class Callback():
    """
    Contains functions that run when a menu item is clicked.
    """
    def launch_controller(cb, item, jump_to=None):
        """
        GTK menu item callback to open the Controller application.

        Params:
            jump_to     (Optional) Opens a specific tab in the Controller (see
                        polychromatic-controller args for options)
        """
        if jump_to:
            dbg.stdout("=> Launch Controller to '{0}' UI".format(jump_to))
        else:
            dbg.stdout("=> Launch Controller", dbg.debug, 1)

        common.execute_polychromatic_component(dbg, "controller", __file__, common.DATA_PATH, jump_to)

    def quit(cb, item):
        """
        GTK menu item callback to quit the application.
        """
        dbg.stdout("Exiting...", dbg.action, 1)
        exit(0)

    def retry_applet(cb, item):
        """
        GTK menu item callback to restart the tray applet.
        """
        dbg.stdout("Restarting applet...", dbg.action, 1)
        os.execv(__file__,  sys.argv)
        exit(0)

    def restart_daemon(cb, item):
        """
        GTK menu item callback to restart the OpenRazer daemon.
        """
        dbg.stdout("=> Restart Daemon", dbg.debug, 1)
        item.set_label(_("Restarting..."))
        item.set_sensitive(False)
        common.restart_openrazer_daemon(dbg, self.path)
        self.retry_applet()

    def set_effect(cb, item, attr):
        """
        GTK menu item to set an effect for a device.

        Params:
            attr    [uid, zone, effect]
        """
        uid = attr[0]
        zone = attr[1]
        effect = attr[2]
        try:
            params = attr[3]
        except Exception:
            params = None

        dbg.stdout("Setting effect for device ID {0} in zone '{1}' to '{2}'".format(uid, zone, effect), dbg.debug, 1)
        r = openrazer.set_device_state(uid, effect, zone, None, [params])
        _verbose_check_status(r)

    def set_brightness(cb, item, attr):
        """
        GTK menu item callback to set the brightness of a device.

        Params:
            attr    [uid, zone, value]
        """
        uid = attr[0]
        zone = attr[1]
        value = attr[2]

        dbg.stdout("Setting brightness for device ID {0} in zone '{1}' to '{2}'".format(uid, zone, value), dbg.debug, 1)
        r = openrazer.set_device_state(uid, "brightness", zone, None, [value])
        _verbose_check_status(r)

    def set_colour(cb, item, attr):
        """
        GTK menu item callback to replay the current effect but use a different
        primary colour.

        Params:
            attr    [uid, zone, hex_string]
        """
        uid = attr[0]
        zone = attr[1]
        hex_value = attr[2]

        dbg.stdout("Setting colour for device ID {0} in zone '{1}' to '{2}'".format(uid, zone, hex_value), dbg.debug, 1)
        r = openrazer.set_device_colours(uid, zone, [hex_value])
        _verbose_check_status(r)

    def set_dpi(cb, item, attr):
        """
        GTK menu item callback to set the DPI of a device.

        Params:
            attr    [uid, new_dpi]
        """
        uid = attr[0]
        new_dpi = attr[1]

        dbg.stdout("Setting DPI for device ID {0} to '{1}'".format(uid, new_dpi), dbg.debug, 1)
        r = openrazer.set_device_state(uid, "dpi", None, None, [new_dpi, new_dpi])
        _verbose_check_status(r)

    def set_poll_rate(cb, item, attr):
        """
        GTK menu item callback to set the poll rate of a device.

        Params:
            attr    [uid, new_poll_rate]
        """
        uid = attr[0]
        new_poll_rate = attr[1]

        dbg.stdout("Setting poll rate for device ID {0} to '{1}'".format(uid, new_poll_rate), dbg.debug, 1)
        r = openrazer.set_device_state(uid, "poll_rate", None, None, [new_poll_rate])
        _verbose_check_status(r)

    def set_game_mode(cb, item, attr):
        """
        GTK menu item callback to set the game mode of a keyboard.

        Params:
            attr    [uid, new_state]
        """
        uid = attr[0]
        state = attr[1]

        dbg.stdout("Setting game mode for device ID {0} to '{1}'".format(uid, state), dbg.debug, 1)
        r = openrazer.set_device_state(uid, "game_mode", None, None, [state])
        _verbose_check_status(r)

    def set_all_effect(cb, item, attr):
        """
        GTK menu item callback to set an effect for all devices (using defaults)

        Params:
            effect_name     Internal effect name
        """
        request = attr[0]
        try:
            params = int(attr[1])
        except Exception:
            params = None

        devices = openrazer.get_device_list()
        dbg.stdout("Setting all devices to '{0}'".format(request), dbg.debug, 1)

        for device in devices:
            if device["available"] == True:
                zones = device["zones"]
                for zone in zones:
                    r = openrazer.set_device_state(int(device["uid"]), request, zone, None, [params])
                    _verbose_check_status(r)

    def set_all_brightness(cb, item, value):
        """
        GTK menu item callback to set the brightness for all devices (or
        on/off if unsupported)

        Params:
            value           String representing brightness %
        """
        value = int(value)

        devices = openrazer.get_device_list()
        dbg.stdout("Setting all brightness levels to {0}%".format(str(value)), dbg.debug, 1)

        for device in devices:
            if device["available"] == True:
                zones = device["zones"]
                for zone in zones:
                    r = openrazer.set_device_state(device["uid"], "brightness", zone, None, [value])
                    _verbose_check_status(r)

    def set_custom_colour(cb, item, attr):
        """
        GTK menu item callback to open a GTK dialogue picker to change the colour
        of a device.

        Params:
            attr    [device object]
        """
        uid = attr[0]
        zone = attr[1]

        dbg.stdout("Opened GTK colour picker.", dbg.debug, 1)
        color_selection_dlg = Gtk.ColorSelectionDialog(_("Set Primary Color"))
        color_selection_result = color_selection_dlg.run()

        if color_selection_result == Gtk.ResponseType.OK:
            result_gdk_colour = color_selection_dlg.get_color_selection().get_current_color()
            red = int(result_gdk_colour.red_float * 255)
            green = int(result_gdk_colour.green_float * 255)
            blue = int(result_gdk_colour.blue_float * 255)
            hex_value = common.rgb_to_hex([red, green, blue])

            dbg.stdout("Set custom colour for device ID {0} to '{1}'".format(uid, hex_value), dbg.debug, 1)
            r = openrazer.set_device_colours(uid, zone, [hex_value])
            _verbose_check_status(r)

        color_selection_dlg.destroy()


def _verbose_check_status(result):
    """
    When using the verbose parameter (-v), output details if a request made
    to the backend (openrazer module) was successful.
    """
    if type(result) == str:
        dbg.stdout("An exception occurred processing this request:", dbg.error, 1)
        dbg.stdout(result, dbg.normal, 1)
    elif result == True:
        dbg.stdout("Request OK", dbg.success, 1)
    elif result == None:
        dbg.stdout("Device missing", dbg.warning, 1)
    elif result == False:
        dbg.stdout("Request unsuccessful - may be unsupported by the device.", dbg.warning, 1)


def parse_parameters():
    """
    Parses the optional parameters for the tray applet.
    """
    global _
    parser = argparse.ArgumentParser(add_help=False)
    parser._optionals.title = _("Optional arguments")
    parser.add_argument("-h", "--help", help=_("Show this help message and exit"), action="help")
    parser.add_argument("-v", "--verbose", help=_("Be verbose to stdout"), action="store_true")
    parser.add_argument("--locale", help=_("Force a specific locale, e.g. de_DE"), action="store")
    parser.add_argument("--force-fallback", help=_("Force GTK Status Icon instead of AppIndicator"), action="store_true")

    args = parser.parse_args()

    if args.verbose:
        dbg.verbose_level = 1
        dbg.stdout(_("Verbose enabled"), dbg.debug, 1)

    if args.locale:
        _ = common.setup_translations(__file__, "polychromatic", args.locale)

    if args.force_fallback:
        global indicator_support
        indicator_support = False


if __name__ == "__main__":
    # Appear as its own process.
    setproctitle("polychromatic-tray-applet")

    # Global variables
    session_storage = os.path.join("/run/user/", str(os.getuid()), "polychromatic-tray-applet")
    _ = common.setup_translations(__file__, "polychromatic")
    dbg = common.Debugging()

    # Kill the process when CTRL+C'd.
    signal.signal(signal.SIGINT, signal.SIG_DFL)

    # Prepare temporary session storage
    if not os.path.exists(session_storage):
        os.makedirs(session_storage)

    # Write a PID file for restarting later.
    f = open(common.PID_FILE_TRAY, 'w')
    f.write(str(os.getpid()))
    f.close()

    parse_parameters()

    # Initialise the indicator
    cb = Callback()
    indicator = AppIndicator()
    indicator.setup()

    Gtk.main()

    # Application Closed
    if os.path.exists(common.PID_FILE_TRAY):
        os.remove(common.PID_FILE_TRAY)
    exit(0)
